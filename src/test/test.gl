shader GBuffer

vert
	inout
		pos, normal, texCoord
		
	matrices
		world, normal, proj, view, mvp
	
	main()
		out.pos = mats.world * in.pos
		out.normal = norm(mats.normal * in.normal)
		out.texCoord = texCoord
		gl_Pos = mats.mvp * in.pos
		
frag
	inout
		albedo, normals, aux, pos
	matrices
		view
	uniforms
		sampler2D diffuseTex
		sampler2D normalTex
		
	main()
		vec3 albedo = texture(s_diffuseTex, v_texCoord0).rgb * u_diffuseColor
		// Albedo (color-tinted diffuse)
		o_albedo = vec4(albedo,1.0)//vec4(albedo, 1.0)
		vec3 viewVec = normalize(u_camPos - v_pos.xyz)
		// Normals & Depth
		o_normalsDepth = normalize(u_mvTrans * vec4(perturb_normal(v_normal, viewVec, v_texCoord0),0.0))
		// Material Properties	
		o_aux = vec4(u_mat, 1.0)
		o_pos = v_pos

	mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )
		// get edge vectors of the pixel triangle
		vec3 dp1 = dFdx( p )
		vec3 dp2 = dFdy( p )
		vec2 duv1 = dFdx( uv )
		vec2 duv2 = dFdy( uv )
	 
		// solve the linear system
		vec3 dp2perp = cross( dp2, N )
		vec3 dp1perp = cross( N, dp1 )
		vec3 T = dp2perp * duv1.x + dp1perp * duv2.x
		vec3 B = dp2perp * duv1.y + dp1perp * duv2.y
	 
		// construct a scale-invariant frame 
		float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) )
		return mat3( T * invmax, B * invmax, N )

	vec3 perturb_normal( vec3 N, vec3 V, vec2 texcoord )
		// assume N, the interpolated vertex normal and 
		// V, the view vector (vertex to eye)
		vec3 map = texture2D( s_normalTex, texcoord ).xyz
		map = map * 255./127. - 128./127.
	   //map.z = sqrt( 1. - dot( map.xy, map.xy ) )
		//map.y = -map.y
		mat3 TBN = cotangent_frame( N, -V, texcoord )
		return normalize( TBN * map )	

